#### 为什么不使用哈希索引、平衡二叉树、B树？

哈希索引：

1. 没有办法范围查找和排序操作
2. 如果多个值的哈希值相同，只能一个一个比较查询效率低

平衡二叉树：

1. 树的高度会越来越高，查找速度越慢
2. 范围查询会有回旋查找的现象，效率低

B树：

1. 范围查询依然会有回旋查找的问题，查询效率低
2. b树每层都要存储具体的数据，那么三层结构存储的数据极低，查找一个数据需要产生大量的磁盘io

#### 主键索引和辅助索引存储结构？

主键索引（聚簇索引）在表中以 <id,row>存储
    
>在主键索引中，id 是主键，我们能够通过 id 找到该行的全部列

辅助索引（非聚簇索引）以<index,id>进行存储，所以在(select *)查询中会出现回表的现象

>在辅助索引中，索引中的几个列构成了键，我们能够通过索引中的列找到 id，
>    
>如果有需要的话，可以再通过 id 找到当前数据行的全部内容


#### mysql一张表大概能存储多少数据?

mysql一个存储页是16k，假如一张表的`parmary key`的类型是`bigint`那么主键所占字节为8byte也就是64bit

而向下的索引指针是6byte，那么就是固定14byte的长度为一条数据

b+树根节点 = 16k = 16 * 1024byte = 16 * 1024 / 14 = 1170 个`parmary key`

因为根节点每条数据都会延申出一个节点，所以第二层的数据量为 1170 * 1170

而第三层存放的为具体的表数据，假如一条数据为1k，那么一个节点就是16条数据，那么最终计算出 1170 * 1170 * 16 = 21902400 条数据

所以在一条数据1k，并且主键为bigint的情况下mysql单表可以存储21902400条数据

#### 调优：为什么要详细评估表的每个字段的长度

假如每个字段都是varchar(255)导致一条数据16k，那么mysql单表存储数据下降为 1170 * 1170 * 1 = 1368900，130万条数据

这样每次查找数据需要加载大量的内存页产生大量的磁盘io，效率极低

#### mysql查找的io和时间复杂度

mysql加载一页为一次io，假设b+树有3层，那么查到具体数据需要进行3次io

而每次取出页数据后，通过二分查找（ologn）找到下层的指针