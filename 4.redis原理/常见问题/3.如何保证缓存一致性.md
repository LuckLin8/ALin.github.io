## 四种方案
1. 先更新缓存->更新数据库
2. 先更新数据库->更新缓存
3. 先淘汰缓存->更新数据库
4. 先更新数据库->淘汰缓存

## 疑问：更新缓存还是淘汰缓存？
### 淘汰缓存
- 优点： 操作简单，无论更新操作是否复杂，直接将缓存中的旧值淘汰
- 缺点： 下次查询会无法在cache中查到，存在一次cache miss，这是需要重新读取数据库

### 更新缓存
- 优点： cache命中率高，不会存在cache miss
- 缺点： 如果更新操作复杂，涉及到其它数据，需要缓存多次与数据库操作，此时更新cache的消耗远大于直接淘汰cache

所以直接淘汰缓存更好，这样每次读取这个数据最多有一次cache miss，但是性能更加稳定

#### 更新cache的另一个问题
直接淘汰cache比更新cache要更好，但是考虑一下更新cache的其它问题


当并发较大，同时有两个线程需要对同一个数据进行更新时，可能会出现以下问题：

方案一、先更新(update)缓存，再更新数据库

>  线程A更新了缓存
>
>  线程B更新了缓存
>
>  线程B更新了数据库
>
>  线程A更新了数据库

方案二、先更新数据库，再更新(update)缓存

>  线程A更新了数据库
>
>  线程B更新了数据库
>
>  线程B更新了缓存
>
>  线程A更新了缓存

并发情况下，如果更新的先后顺序存在明确要求，更新cache 的方案会导致数据不一致，只有进行‘串行化’（加锁更新）

由上得，更新cache消耗大，会导致数据不一致，所以选择直接淘汰cache

### 顺序：先淘汰缓存还是先更新数据库？

#### 首先考虑执行失败的问题

方案一：先淘汰缓存后更新数据库
缓存淘汰后，更新数据库失败，此时再次查询缓存，最多会出现一次cache miss

方案二：先更新数据库后淘汰缓存
数据库更新成功，缓存淘汰失败会导致缓存中的数据长时间不一致

解决方案：重试机制，删除缓存失败后，由业务代码再次重试，直到缓存被删除
使用mq进行消费重试，直到删除成功

#### 先淘汰cache，再更新数据库：
  采用同步更新缓存的策略，可能会导致数据长时间不一致，如果用延迟双删来优化，还需要考虑究竟需要延时多长时间的问题——读的效率较高，但数据的一致性需要靠其它手段来保证
  采用异步更新缓存的策略，不会导致数据不一致，但在数据库更新完成之前，都需要到数据库层面去读取数据，读的效率不太好——保证了数据的一致性，适用于对一致性要求高的业务
#### 先更新数据库，再淘汰cache：
  无论是同步/异步更新缓存，都不会导致数据的最终不一致，在更新数据库期间，cache中的旧数据会被读取，可能会有一段时间的数据不一致，但读的效率很好——保证了数据读取的效率，如果业务对一致性要求不是很高，这种方案最合适