#### Netty是什么

Netty是一个异步的，基于事件驱动的网络应用框架，用于开发高性能，高可靠的网络IO程序

Netty本质是一个NIO框架，针对TCP协议

#### 应用场景：

dubbo的默认传输协议dubbo协议底层默认使用的是Netty框架

#### IO模型

AIO的做法是，每个水壶上装一个开关，当水开了以后会提醒对应的线程去处理。
NIO的做法是，叫一个线程不停的循环观察每一个水壶，根据每个水壶当前的状态去处理。
BIO的做法是，叫一个线程停留在一个水壶那，直到这个水壶烧开，烧n壶水需要n个线程去处理水壶。



- BIO：同步阻塞io，服务器实现模式是一个连接一个线程，即客户端有连接请求服务端就必须启动一个线程进行处理，如果连接不做任何事情就会有额外的线程开销

  **使用于连接数少**

- NIO：同步非阻塞，服务器实现一个线程处理多个请求，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有I/O请求就去处理，Netty底层用的是NIO模型

  **适用于连接数目多且连接比较短，聊天、弹幕、服务器间通讯**

- AIO：异步非阻塞，AIO引入异步通道的概念，采用Proactor模式，简化程序的编写，有效的请求才启动线程，无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理

  **连接数目多且连接比较长，比如相册服务器**



**BIO的问题：**

每个请求都要有独立的线程处理，并发数大的时候需要创建大量的线程，连接建立后如果无数据可读，线程会阻塞在Read操作上，造成线程浪费

#### 原生NIO的问题

1. `NIO` 的类库和 `API` 繁杂，使用麻烦：需要熟练掌握 `Selector`、`ServerSocketChannel`、`SocketChannel`、`ByteBuffer`等。
2. 需要具备其他的额外技能：要熟悉 `Java` 多线程编程，因为 `NIO` 编程涉及到 `Reactor` 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 `NIO` 程序。
3. 开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。
4. `JDK NIO` 的 `Bug`：例如臭名昭著的 `Epoll Bug`，它会导致 `Selector` 空轮询，最终导致 `CPU100%`。直到 `JDK1.7` 版本该问题仍旧存在，没有被根本解决。

#### Netty的优点

`Netty` 对 `JDK` 自带的 `NIO` 的 `API` 进行了封装，解决了上述问题。

1. 设计优雅：适用于各种传输类型的统一 `API` 阻塞和非阻塞 `Socket`；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。
2. 使用方便：详细记录的 `Javadoc`，用户指南和示例；没有其他依赖项，`JDK5（Netty3.x）`或 `6（Netty4.x）`就足够了。
3. 高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。
4. 安全：完整的 `SSL/TLS` 和 `StartTLS` 支持。
5. 社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 `Bug` 可以被及时修复，同时，更多的新功能会被加入。

